## 풀스택 개발자 & ESG 컨설턴트 포트폴리오/블로그 웹/앱 애플리케이션 PRD (Product Requirements Document)

**문서 정보:**
*   **문서 제목:** 풀스택 개발자 & ESG 컨설턴트 포트폴리오/블로그 애플리케이션 - 아키텍처 PRD
*   **버전:** 통합 Blog Service 및 Portfolio 정적 렌더링 확정 반영
*   **작성일:** 2025년 5월 27일 
*   **대상 독자:** 개발자 PM, 개발 팀

---

### 1. 개요 (Executive Summary)

본 문서는 풀스택 웹개발자 겸 ESG 컨설턴트로서 개인의 역량, 경험, 지식을 효과적으로 보여주고 공유하기 위한 웹/앱 애플리케이션 개발 프로젝트의 아키텍처 및 주요 요구사항을 정의합니다. 우리는 **마이크로서비스 아키텍처(MSA)와 API Gateway 패턴**을 기반으로 FastAPI 프레임워크와 Docker 컨테이너를 활용하여 **유연하고 확장 가능하며 유지보수가 용이한 시스템**을 구축하고자 합니다.

최근 논의 결과, `Portfolio Service`는 별도의 백엔드 마이크로서비스 없이 프론트엔드 기반의 정적 데이터 렌더링 방식으로 확정되었으며, `Blog Service`와 `ESG Service`는 **콘텐츠 타입(개발/ESG)을 구분하는 단일 `Blog Service`로 통합**되었습니다. 이는 시스템의 단순성을 높이고, 개발 및 운영의 효율성을 극대화하기 위함입니다. 본 문서의 후반부에는 이 결정에 기반한 상세 작업 분할 및 우선순위가 제시됩니다.

### 2. 문제 정의 (Problem Statement)

기존의 개인 포트폴리오 및 블로그는 보통 하나의 웹사이트에서 통합 관리되거나, 별도의 플랫폼에 분산되어 있어 일관된 브랜딩과 콘텐츠 관리가 어렵습니다. 특히 "풀스택 개발"과 "ESG 컨설팅"이라는 두 가지 전문 분야를 동시에 보여주는 통합된 플랫폼은 찾아보기 어렵습니다. 이는 다음과 같은 문제를 야기합니다:
*   개인의 다재다능한 역량을 효과적으로 어필하기 어려움.
*   개발 및 ESG 관련 깊이 있는 지식을 체계적으로 공유하는 데 한계.
*   방문자와의 상호작용 및 피드백 관리가 비효율적.
*   콘텐츠 업데이트 및 관리의 번거로움.

### 3. 제품 목표 (Product Goals)

*   **전문성 강화:** 풀스택 개발 및 ESG 컨설팅 역량을 통합적으로 보여주는 고품질 포트폴리오 및 블로그 플랫폼 제공.
*   **지식 공유 허브:** 개발 트렌드, ESG 이슈, 개인 인사이트를 공유하는 신뢰성 있는 콘텐츠 채널 구축.
*   **커뮤니케이션 활성화:** 방문자가 콘텐츠에 쉽게 접근하고, 댓글 등을 통해 상호작용할 수 있는 환경 제공.
*   **운영 효율성:** 관리자(본인)가 블로그 콘텐츠(개발/ESG)를 쉽고 빠르게 관리할 수 있는 백엔드 시스템 구현. **포트폴리오 콘텐츠는 정적 파일/코드 기반으로 효율적인 관리를 지향합니다.**
*   **기술적 유연성:** 향후 기능 확장 및 서비스 추가 시 기존 시스템에 미치는 영향을 최소화하고, 독립적인 개발/배포가 가능한 구조 확보.

### 4. 핵심 기능 요구사항 (Functional Requirements)

애플리케이션은 크게 다음과 같은 핵심 기능들을 제공해야 합니다.

#### 4.1. 사용자 기능 (방문자)
*   **포트폴리오 열람:**
    *   개인 프로젝트 목록 및 상세 정보 (기술 스택, 역할, 기여도, 이미지/링크 포함) 조회.
    *   기술 스택, 경력, 학력, 자격증, 자기소개 등 개인 프로필 정보 열람.
    *   (참고: 이 데이터는 백엔드 API 호출 없이 프론트엔드에서 직접 렌더링됩니다.)
*   **블로그/콘텐츠 열람 (통합):**
    *   게시글 목록(카테고리, 태그별 필터링 포함) 조회 및 검색.
        *   **개발 관련 블로그 게시글**: `post_type = 'dev'`
        *   **ESG 관련 콘텐츠/인사이트 게시글**: `post_type = 'esg'`
    *   개별 게시글 상세 내용 열람.
    *   게시글에 댓글 작성 (비회원/회원 가능).
    *   최신/인기 게시글 조회.
*   **연락 기능:**
    *   이메일, LinkedIn 등 연락처 정보 확인.

#### 4.2. 관리자 기능 (본인)
*   **인증 및 인가:** 안전한 로그인 및 관리자 대시보드 접근.
*   **포트폴리오 콘텐츠 관리:**
    *   **직접 JSON 파일 편집 또는 프론트엔드 코드 내에 데이터를 정의 (e.g., Markdown/TypeScript 파일)하여 관리합니다.** (별도의 백엔드 API/DB 없음)
    *   이 변경은 GitHub와 같은 버전 관리 시스템을 통해 이력을 관리하고, 자동 배포를 통해 웹에 반영됩니다.
*   **블로그/콘텐츠 관리 (통합):**
    *   **개발 관련 게시글 및 ESG 관련 콘텐츠** 생성/조회/수정/삭제 (CRUD), 미리보기 기능.
        *   게시글 작성 시 `post_type` 필드를 통해 개발 또는 ESG 콘텐츠로 구분하여 저장.
    *   카테고리 및 태그 생성/관리 (개발/ESG 통합).
    *   댓글 승인/삭제 및 관리.

### 5. 비기능 요구사항 (Non-Functional Requirements)

*   **성능:**
    *   API 응답 시간: 대부분의 요청에 대해 200ms 이내 응답.
    *   페이지 로딩 시간: 3초 이내. **특히 포트폴리오 섹션은 정적 콘텐츠 서빙으로 초고속 응답 가능.**
*   **확장성:**
    *   트래픽 증가에 따라 각 **마이크로서비스(Auth, Blog)**별로 독립적인 수평 확장이 가능해야 함.
    *   **포트폴리오 정적 콘텐츠는 CDN을 통해 무한에 가깝게 확장 가능.**
    *   향후 신규 서비스 추가 시 기존 시스템에 미치는 영향 최소화.
*   **신뢰성/가용성:**
    *   24/7 서비스 가능 (계획된 유지보수 시간 제외).
    *   단일 장애 지점(SPOF) 최소화.
*   **보안:**
    *   모든 통신은 HTTPS/SSL을 통해 암호화.
    *   JWT 기반의 안전한 인증 및 인가 시스템.
    *   데이터베이스 접근 권한 관리 및 민감 정보 암호화 (예: 비밀번호 해싱).
    *   API Gateway를 통한 속도 제한 (Rate Limiting) 적용.
    *   **포트폴리오 정적 콘텐츠는 별도의 백엔드 로직이 없어 공격 표면이 감소합니다.**
*   **유지보수성:**
    *   각 마이크로서비스는 독립적인 코드베이스를 가지며, 명확한 책임과 모듈화를 통해 유지보수 용이성 확보.
    *   **포트폴리오 부분은 백엔드 서비스 없이 프론트엔드/정적 파일 관리로 유지보수 부담이 감소합니다.**
    *   **Blog/ESG 콘텐츠의 통합 관리를 통해 백엔드 서비스 수가 줄어 관리 복잡성이 감소합니다.**
    *   명확한 API 문서화 (OpenAPI/Swagger).
*   **배포 용이성:**
    *   Docker 컨테이너를 통한 환경 독립적인 배포 및 실행.
    *   CI/CD 파이프라인 구축을 통한 자동화된 빌드, 테스트, 배포.
*   **모니터링 및 로깅:**
    *   각 마이크로서비스의 로그를 중앙 집중식으로 수집 및 관리.
    *   서비스 상태, 성능 지표(CPU, 메모리, 응답 시간, 에러율 등)를 모니터링할 수 있는 시스템 구축.

### 6. 아키텍처 설계 (Architecture Design)

우리는 **FastAPI 기반의 API Gateway 패턴을 적용한 마이크로서비스 아키텍처(MSA)**를 채택하며, **포트폴리오 콘텐츠는 프론트엔드 정적 데이터 렌더링 방식**으로 구성합니다. 이는 시스템의 단순성과 효율성을 추구하며, 모든 서비스는 Docker 컨테이너로 패키징되어 배포 및 관리가 용이합니다.

#### 6.1. High-Level 아키텍처 다이어그램

```
+----------------+          +-------------------+          +-------------------+
|    클라이언트    |          |                   |          |                   |
|  (Web 브라우저)  +--------->+    API Gateway    +--------->+  인증 서비스 (Auth) |
|  (모바일 앱)   |          |    (FastAPI)      |          |   (FastAPI + DB)   |
+----------------+          |                   |          +-------------------+
        ^                   |  - 요청 라우팅      |          |                   |
        |                   |  - 인증/인가       +--------->+   블로그 서비스   |
        |                   |  - 속도 제한        |          | (Blog & ESG 통합) |
        |                   |  - 통합 로깅        |          |   (FastAPI + DB)  |
        |                   |                   |          +-------------------+
        |                   +-------------------+
        |
        | 직접 접근
        | (정적 파일)
        |
+--------------------------+
| Static Asset Hosting     |
| (e.g., S3 + CloudFront)  |
| - portfolio.json         |
| - images                 |
+--------------------------+
```

#### 6.2. 핵심 컴포넌트 상세

**1. API Gateway (FastAPI)**
*   **역할:** 클라이언트의 모든 동적 요청(인증, 블로그/콘텐츠)을 받아 적절한 백엔드 마이크로서비스로 라우팅하는 단일 진입점입니다. **포트폴리오 콘텐츠는 직접 라우팅하지 않습니다.**
*   **주요 기능:**
    *   **요청 라우팅:** `api/auth/*`, `api/blog/*` (개발/ESG 콘텐츠 통합) 등으로 요청을 포워딩합니다.
    *   **통합 인증/인가:** JWT(JSON Web Token) 기반의 인증을 중앙에서 처리하고, 필요한 경우 인가 검증을 수행합니다. 검증된 사용자 정보(ID, 역할)는 HTTP 헤더를 통해 하위 서비스로 전달합니다.
    *   **속도 제한 (Rate Limiting):** DoS 공격 방지 및 서비스 부하 조절을 위해 클라이언트 IP 또는 사용자별 요청 속도를 제어합니다.
    *   **통합 로깅:** 모든 인바운드 요청에 대한 로그를 수집하여 모니터링 시스템으로 전달합니다.
    *   **오류 처리:** 하위 서비스에서 발생한 오류를 일관된 형식으로 클라이언트에 전달합니다.
*   **기술 스택:** FastAPI, httpx (비동기 HTTP 클라이언트), PyJWT

**2. 마이크로서비스 (FastAPI)**
각 마이크로서비스는 독립적인 비즈니스 도메인과 데이터베이스를 소유하며, 단일 책임 원칙을 따릅니다.
*   **인증 서비스 (Auth Service):**
    *   **책임:** 사용자 등록, 로그인, JWT 토큰 발급 (Gateway와 연동하여 JWT 서명), 사용자 프로필 관리(비밀번호 변경 등).
    *   **데이터베이스:** `users` 테이블.
*   **블로그 서비스 (Blog Service - 통합):**
    *   **책임:** **개발 관련 블로그 게시글, ESG 관련 콘텐츠/인사이트, 카테고리, 태그, 댓글 데이터의 CRUD 및 조회 기능을 통합하여 제공합니다.** `post_type` 필드를 통해 개발 및 ESG 콘텐츠를 구분합니다.
    *   **데이터베이스:** `posts` (type 필드 포함), `categories`, `tags`, `comments` 테이블.
*   **공통 기술 스택:** FastAPI, SQLAlchemy (ORM), PostgreSQL (데이터베이스), Pydantic

**3. Static Portfolio Content Hosting**
*   **역할:** 포트폴리오 데이터(프로젝트, 스킬, 경력 등)를 JSON 파일 또는 프론트엔드 코드 내에 정의하고, 이를 정적 파일 형태로 웹 서버(CDN 연동)를 통해 직접 제공합니다.
*   **기술 스택 (대안 중 택 1):**
    *   **대안 1 (권장): 정적 JSON + CDN 서빙:**
        *   `portfolio.json` 형태로 GitHub 저장소 또는 AWS S3에 저장.
        *   S3에 저장된 JSON 파일을 CloudFront (CDN)를 통해 서빙하여 초고속 응답 보장.
        *   수정은 직접 JSON 파일 편집 또는 Notion/CMS ↔ JSON 자동 변환 도구 연동 고려.
        *   프론트엔드는 이 JSON 파일을 불러와 렌더링만 수행.
    *   **대안 2: Next.js Static Props 기반 관리 (`getStaticProps`):**
        *   `projects.ts`, `skills.ts` 같은 프론트엔드 코드 파일 내에 데이터를 하드코딩 (CMS처럼 사용).
        *   Next.js의 `getStaticProps`를 사용하여 빌드 시 정적 HTML 파일 생성.
        *   Vercel, Netlify 등 정적 호스팅 서비스에 자동 배포 연결.
*   **장점:** 서버리스, 초고속 로딩, 백엔드 관리 부담 최소화, 비용 효율적, Git 기반 버전 관리 용이.

**4. 데이터베이스 (PostgreSQL)**
*   **원칙:** 각 마이크로서비스(Auth, 통합 Blog)는 자신만의 데이터베이스(또는 독립적인 스키마)를 가집니다. PostgreSQL은 안정성과 확장성, 그리고 비동기 드라이버(asyncpg)와의 호환성으로 선택되었습니다. **Portfolio 데이터는 별도의 DB가 필요 없습니다.**

**5. 컨테이너화 (Docker)**
*   모든 API Gateway 및 마이크로서비스는 Docker 컨테이너로 빌드 및 실행됩니다. 이는 개발 환경과 운영 환경 간의 일관성을 보장하고, 배포 과정을 단순화하며, 각 서비스의 격리된 실행 환경을 제공합니다.

**6. 오케스트레이션 (Docker Compose / Docker Swarm / Kubernetes)**
*   **개발 환경:** Docker Compose를 사용하여 모든 서비스(Gateway, Microservices, Databases)를 로컬에서 쉽게 정의하고 실행, 관리할 수 있습니다. **포트폴리오 정적 콘텐츠는 개발 서버 또는 로컬 파일 시스템에서 직접 제공됩니다.**
*   **운영 환경:** Docker Swarm 또는 Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 서비스의 고가용성, 로드 밸런싱, 자동 확장, 셀프-힐링 등을 관리합니다. 이는 실제 운영 환경에서의 안정성과 효율성을 극대화합니다.

**7. 프론트엔드 애플리케이션 (예: React/Next.js for Web, Flutter/React Native for Mobile)**
*   클라이언트 단의 UI/UX를 담당하며, API Gateway를 통해 백엔드 서비스(Auth, 통합 Blog)와 통신합니다. **포트폴리오 데이터는 API Gateway를 거치지 않고 직접 Static Asset Hosting에서 가져와 렌더링합니다.** 웹 및 모바일 환경에 최적화된 사용자 경험을 제공합니다.

### 7. 배포 및 운영 전략

*   **CI/CD 파이프라인:**
    *   **Continuous Integration (CI):** Git 저장소에 코드 변경이 푸시될 때마다 자동화된 테스트(유닛, 통합)를 실행하고, 성공 시 Docker 이미지를 빌드하여 컨테이너 레지스트리(예: Docker Hub, GitLab Registry)에 저장합니다.
    *   **Continuous Deployment (CD):** 새로운 이미지가 레지스트리에 푸시되면, 운영 환경에 자동으로 배포됩니다. 무중단 배포(Rolling Update) 전략을 사용하여 서비스 중단 없이 업데이트를 진행합니다. **포트폴리오 정적 콘텐츠의 경우, GitHub Actions 등을 통해 S3에 동기화하거나 Next.js 빌드 후 정적 호스팅 서비스로 배포하는 방식이 적용됩니다.**
*   **모니터링 및 로깅:**
    *   Prometheus와 Grafana를 사용하여 각 마이크로서비스의 성능 지표(CPU, 메모리, 네트워크, 응답 시간, 에러율 등)를 실시간으로 모니터링합니다.
    *   ELK Stack (Elasticsearch, Logstash, Kibana) 또는 Grafana Loki + Promtail을 사용하여 모든 서비스의 로그를 중앙 집중식으로 수집하고 분석합니다. **포트폴리오 정적 콘텐츠는 별도의 서버 로그가 발생하지 않아 모니터링 부담이 적습니다.**
*   **백업 및 복구:** 각 마이크로서비스의 데이터베이스는 정기적으로 백업되며, 재해 발생 시 복구 계획을 수립합니다.

### 8. 기대 효과 및 고려사항

#### 8.1. 기대 효과 (Benefits)
*   **개발 및 배포 속도 향상:** 각 서비스의 독립적인 개발 및 배포로, 전체 시스템에 미치는 영향 없이 빠르게 기능을 추가하고 배포할 수 있습니다. **특히 포트폴리오 부분은 백엔드 개발 및 배포 과정이 생략되어 더욱 빠릅니다.**
*   **기술적 유연성:** 각 서비스별로 최적의 기술 스택을 선택할 수 있는 유연성 (본 프로젝트에서는 FastAPI로 통일).
*   **높은 확장성:** 특정 마이크로서비스의 트래픽이 급증할 경우, 해당 서비스만 독립적으로 확장하여 전체 시스템의 안정성을 유지할 수 있습니다. **포트폴리오 정적 콘텐츠는 CDN의 글로벌 분산 특성으로 높은 트래픽을 효율적으로 처리합니다.**
*   **강화된 복원력:** 하나의 마이크로서비스에 장애가 발생하더라도 다른 서비스에는 영향을 미치지 않아 시스템 전체의 안정성이 향상됩니다.
*   **명확한 책임 분리:** 각 서비스가 명확한 비즈니스 책임을 가지므로, 코드의 이해와 유지보수가 용이합니다.
*   **운영 비용 절감:** 포트폴리오 서비스에 대한 백엔드 인프라(서버, DB) 비용이 발생하지 않으며, Blog/ESG 통합으로 백엔드 서비스 수가 줄어듭니다.
*   **보안 강화:** 백엔드 API가 없는 정적 콘텐츠는 공격 표면이 현저히 줄어듭니다.

#### 8.2. 고려사항 (Challenges & Risks)
*   **초기 설정 복잡성:** 모놀리식 아키텍처에 비해 시스템 구성 및 환경 설정이 더 복잡할 수 있습니다. (Docker Compose로 개발 편의성 확보)
*   **서비스 간 통신 오버헤드:** 네트워크 호출로 인한 성능 지연이 발생할 수 있으나, Gateway를 통한 효율적인 라우팅과 비동기 통신으로 최소화합니다.
*   **분산 데이터 관리:** 각 서비스별 독립적인 데이터베이스로 인한 데이터 일관성 유지 문제가 발생할 수 있으며, 이에 대한 전략(최종 일관성)을 고려해야 합니다.
*   **운영 복잡성:** 여러 서비스를 동시에 관리하고 모니터링해야 하므로, 통합 로깅/모니터링 시스템 구축이 필수적입니다. (Prometheus, Grafana, ELK 도입으로 관리)
*   **포트폴리오 데이터 업데이트 방식:** JSON 파일 직접 편집 또는 프론트엔드 코드 수정 방식이므로, 관리자 UI를 통한 실시간 CRUD 업데이트는 제공되지 않습니다. 이는 Git 기반의 버전 관리와 CI/CD 파이프라인을 통해 보완됩니다.

### 9. 성공 지표 (Success Metrics)

*   **성능:** API 응답 시간 95%가 목표 응답 시간(200ms) 충족. 포트폴리오 섹션 로딩 시간 1초 이내.
*   **가용성:** 시스템 가동 시간 99.9% 이상 유지.
*   **관리 효율성:** 블로그 콘텐츠(개발/ESG) 관리자 기능 사용을 통한 콘텐츠 업데이트 시간 50% 단축.
*   **사용자 만족도:** 방문자 이탈률 감소, 댓글 및 페이지뷰 증가.

### 10. 프로젝트 작업 분할 및 우선순위 (Project Task Breakdown and Priority)

개발자 PM님과의 논의를 통해 결정된 작업 분할 및 우선순위는 다음과 같습니다.

#### 🚩 Phase 1: 환경 구성 및 아키텍처 설계 (High Priority)
1.  **프로젝트 리포지토리 및 폴더 구조 설정**
2.  **Docker 환경 구성**
    *   Dockerfile 작성 (FastAPI, PostgreSQL)
    *   `docker-compose.yml` 초기 환경 구성
3.  **FastAPI API Gateway 기본 설정**
    *   FastAPI 기본 라우팅 구성 (Auth, Blog)
    *   기본 JWT 인증 미들웨어 설정

#### 🚩 Phase 2: Auth Service 구현 (High Priority)
1.  **DB 스키마 정의 및 설정 (PostgreSQL)**
2.  **사용자 인증 및 인가 기능 구현**
    *   회원가입 및 로그인 API
    *   JWT 생성 및 검증 로직
3.  **Docker Compose Auth 서비스 통합 및 테스트**

#### ✅ Phase 3: Portfolio 서비스 제거 및 정적 데이터 렌더링 전환
1.  **Next.js의 `getStaticProps()` 또는 Markdown 기반 포트폴리오 데이터 구성**
2.  **프로젝트, 기술스택, 자격증 등의 데이터 Markdown/JSON 파일 형태로 작성**
3.  **정적 파일 또는 CMS 없는 정적 웹사이트로 렌더링 구성**

#### 🚩 Phase 4: Blog Service (통합형) 구현 (High Priority)
1.  **DB 스키마 정의 및 설정 (PostgreSQL)**
    *   `post_type` 필드를 통해 `dev` (개발)와 `esg` (ESG) 주제를 구분
2.  **블로그 콘텐츠 CRUD API 개발**
    *   게시글, 카테고리, 태그, 댓글 기능 통합 구현
    *   개발글과 ESG글을 API 레벨에서 `post_type` 필터를 통해 분기 처리
3.  **Docker Compose Blog 서비스 통합 및 테스트**

#### 🚩 Phase 5: API Gateway 고도화 (Medium Priority)
1.  **속도 제한(Rate Limiting) 및 캐싱 전략 적용**
2.  **중앙 로깅 및 모니터링 설정**
    *   Prometheus, Grafana 및 ELK 구성

#### 🚩 Phase 6: 프론트엔드 개발 및 통합 (Medium Priority)
1.  **기본 React 또는 Next.js 애플리케이션 셋업**
2.  **API Gateway를 통한 백엔드 API 연동 및 테스트 (Auth, Blog)**
3.  **Markdown 기반 포트폴리오 및 블로그 콘텐츠 정적 렌더링 통합**
4.  **Docker 환경에서 프론트엔드 서비스 실행 및 테스트**

#### 🚩 Phase 7: CI/CD 파이프라인 구축 (Low Priority, after MVP)
1.  **GitHub Actions 또는 GitLab CI를 사용한 CI/CD 구축**
2.  **Docker 이미지 빌드 및 컨테이너 레지스트리 푸시 자동화**
3.  **배포 파이프라인 및 롤링 업데이트 전략 설정**

#### 🚩 Phase 8: 추가 보안 및 확장성 고려 (Low Priority, ongoing)
1.  **서비스 디스커버리 및 로드 밸런싱 설정**
2.  **보안 강화 (네트워크 정책, 데이터 암호화 등)**
3.  **데이터베이스 백업 및 복구 전략 구현**

---

### 📌 추가로 필요한 사항
*   작업별 상세 일정과 담당자 명시
*   각 단계별 테스트 케이스 작성 및 자동화 테스트 전략 설정
*   운영 환경에서의 배포 전략 (Docker Swarm vs Kubernetes 결정)

---

